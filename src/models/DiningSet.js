/* eslint-disable react/no-unknown-property */
/* eslint-disable react/no-children-prop */
/* eslint-disable react/prop-types */

/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
*/
import { Merged, useGLTF } from "@react-three/drei";
import { useFrame, useLoader } from "@react-three/fiber";
import React, {
  createContext,
  useContext,
  useLayoutEffect,
  useMemo,
  useRef,
  useState
} from "react";
import * as THREE from "three";
import { TextureLoader } from "three/src/loaders/TextureLoader";
import { subscribe } from "valtio";
// import { useToggle } from "react-use";
import ObjectTransformControls from "../components/ObjectTransformControls";
// import { useSceneObjects } from "../store/useSceneObjects";
import { sceneActions, sceneStateStore } from "../store/sceneData";

const context = createContext();

export function DiningSetInstances({ children, ...props }) {
  const { nodes } = useGLTF("/dining_set-transformed.glb");

  const instances = useMemo(
    () => ({
      Body: nodes.Body1__0,
      BodyPolyurethane: nodes.Body1_Polyurethane_0,
      BodyDMahoganyGlossy: nodes["Body38_3D_Mahogany_-_Glossy_0"],
      BodyMirror: nodes.Body42_Mirror_0,
      BodyGlassMediumColor: nodes["Body45_Glass_-_Medium_Color_0"],
      BodyDMahoganyGlossy1: nodes["Body46_3D_Mahogany_-_Glossy_0"],
      Body1: nodes.Body47__0,
      BodyPolyurethane1: nodes.Body47_Polyurethane_0,
      Body2: nodes.Body48__0,
      BodyPolyurethane2: nodes.Body48_Polyurethane_0,
      Body3: nodes.Body49__0,
      BodyPolyurethane3: nodes.Body49_Polyurethane_0,
      Body4: nodes.Body50__0,
      BodyPolyurethane4: nodes.Body50_Polyurethane_0,
      BodyOpaque: nodes["Body51_Opaque(152,170,175)_0"],
      BodyOpaque1: nodes["Body56_Opaque(152,170,175)_0"],
      BodyOpaque2: nodes["Body57_Opaque(152,170,175)_0"],
      BodyOpaque3: nodes["Body58_Opaque(152,170,175)_0"],
      BodyOpaque4: nodes["Body59_Opaque(152,170,175)_0"],
      BodyGlassLightColor: nodes["Body61_Glass_-_Light_Color_0"],
      BodyGlassLightColor1: nodes["Body62_Glass_-_Light_Color_0"],
      BodyGlassLightColor2: nodes["Body63_Glass_-_Light_Color_0"],
      BodyGlassLightColor3: nodes["Body64_Glass_-_Light_Color_0"],
      BodyGlassLightColor4: nodes["Body65_Glass_-_Light_Color_0"],
    }),
    [nodes]
  );
  return (
    <Merged meshes={instances} {...props}>
      {(instances) => (
        <context.Provider value={instances} children={children} />
      )}
    </Merged>
  );
}

export function DiningSet(props) {
  const instances = useContext(context);

  // const [active, toggleActive] = useToggle(false);

  const objectRef = useRef();

  const [transformController, setTransformController] = useState(false);

  // const rigidDiningSet = useRef();

  // useFrame(() => {
  //   if (rigidDiningSet.current) {
  //     rigidDiningSet.current.setTranslation({
  //       x: props.position.x,
  //       y: props.position.y,
  //       z: props.position.z,
  //     });
  //   }
  // });

  const [colliderColor, setColliderColor] = useState(false);

  useFrame(() => {
    if (objectRef.current) {
      if (objectRef.current.position.y < 0) {
        setColliderColor(true);
      } else {
        setColliderColor(false);
      }
    }
  });

  const bodyRef = useRef();

  // const textureColorMap = useLoader(
  //   TextureLoader,
  //   "texture_Color_WickerIndividualSimpleRattan001_COL_2K.jpg"
  // );

  // const [textureMap] = useLoader(
  //   TextureLoader,
  //   ["texture_Color_MetalStainlessSteelBrushedElongated005_COL_2K_METALNESS.jpg"]
  // );

  const [rattanColorMap, mahoganyColorMap] = useLoader(TextureLoader, [
    "texture_Color_WickerIndividualSimpleRattan001_COL_2K.jpg",
    "texture_Color_WoodFlooringMahoganyAfricanSanded001_COL_2K.jpg",
  ]);

  useLayoutEffect(() => {
    // }),
    // if (bodyRef.current) {
    /** Rattan Texture */
    // bodyRef.current.instance.current.material.map = textureColorMap;

    // textureColorMap.wrapS = THREE.RepeatWrapping;
    // textureColorMap.wrapT = THREE.RepeatWrapping;

    // bodyRef.current.instance.current.material.color = new THREE.Color(0.93, 0.8, 0.61);
    // bodyRef.current.instance.current.material.emissive = new THREE.Color(0, 0, 0);

    /** Metal Texture */
    // bodyRef.current.instance.current.material.color = new THREE.Color(1, 1, 1);
    // bodyRef.current.instance.current.material.emissive = new THREE.Color(0, 0, 0);
    // bodyRef.current.instance.current.material.metalness = 1;
    // bodyRef.current.instance.current.material.roughness = 0;

    /** Mahogany Texture */
    // bodyRef.current.instance.current.material.map = colorMap;

    // colorMap.wrapS = THREE.RepeatWrapping;
    // colorMap.wrapT = THREE.RepeatWrapping;

    // colorMap.repeat.set(0.05, 0.05);

    // bodyRef.current.instance.current.material.color = new THREE.Color(
    //   0.396,
    //   0.247,
    //   0.164
    // );
    // bodyRef.current.instance.current.material.emissive = new THREE.Color(
    //   0,
    //   0,
    //   0
    // );

    // bodyRef.current.instance.current.material.roughness = 0.3;
    subscribe(sceneStateStore, () => {
      if (sceneStateStore.current.texture === "rattan") {
        bodyRef.current.instance.current.material.map = rattanColorMap;

        rattanColorMap.wrapS = THREE.RepeatWrapping;
        rattanColorMap.wrapT = THREE.RepeatWrapping;

        rattanColorMap.repeat.set(0.05, 0.05);

        bodyRef.current.instance.current.material.color = new THREE.Color(
          0.93,
          0.8,
          0.61
        );
        bodyRef.current.instance.current.material.emissive = new THREE.Color(
          0,
          0,
          0
        );
        bodyRef.current.instance.current.material.metalness = 0;
        bodyRef.current.instance.current.material.roughness = 0.6;
        bodyRef.current.instance.current.material.needsUpdate = true;
      } else if (sceneStateStore.current.texture === "metal") {
        bodyRef.current.instance.current.material.color = new THREE.Color(
          1,
          1,
          1
        );
        bodyRef.current.instance.current.material.emissive = new THREE.Color(
          0,
          0,
          0
        );
        bodyRef.current.instance.current.material.metalness = 1;
        bodyRef.current.instance.current.material.roughness = 0;
        bodyRef.current.instance.current.material.needsUpdate = true;
      } else if (sceneStateStore.current.texture === "mahogany") {
        bodyRef.current.instance.current.material.map = mahoganyColorMap;
        mahoganyColorMap.wrapS = THREE.RepeatWrapping;
        mahoganyColorMap.wrapT = THREE.RepeatWrapping;
        mahoganyColorMap.repeat.set(0.05, 0.05);
        bodyRef.current.instance.current.material.color = new THREE.Color(
          0.396,
          0.247,
          0.164
        );
        bodyRef.current.instance.current.material.emissive = new THREE.Color(
          0,
          0,
          0
        );
        bodyRef.current.instance.current.material.metalness = 0;
        bodyRef.current.instance.current.material.roughness = 0.3;
        bodyRef.current.instance.current.material.needsUpdate = true;
      } else if (sceneStateStore.current.texture === "default") {
        bodyRef.current.instance.current.material.color = new THREE.Color(
          0.182,
          0.105,
          0
        );
        bodyRef.current.instance.current.material.emissive = new THREE.Color(
          0,
          0,
          0
        );
        bodyRef.current.instance.current.material.roughness = 0.6;
        bodyRef.current.instance.current.material.metalness = 0;
        bodyRef.current.instance.current.material.needsUpdate = true;
        bodyRef.current.instance.current.material.map = null;
      }
    });
  }, []);

  /** Set sensor interaction for colliding meshes */
  // const [intersecting, setIntersection] = useState(false);

  // /** Update position of rigid body */
  // const rigidDiningSetRef = useRef();

  // useFrame(() => {
  //   rigidDiningSetRef.current.setNextKinematicTranslation({
  //     x: props.position.x,
  //     y: props.position.y,
  //     z: props.position.z,
  //   });
  // });

  /** Dragging function to set position */
  // const [dragging, setDragging] = useState(false);
  // const [s] = useState({
  //   mouse: null,
  // });
  // const { mouse, camera } = useThree();

  // useEffect(() => {
  //   if (dragging) {
  //     document.body.style.cursor = "grabbing";
  //     cameraActions.setCameraOrbit(false);
  //   } else {
  //     document.body.style.cursor = "";
  //     cameraActions.setCameraOrbit(true);
  //     s.mouse = null;
  //   }
  // }, [dragging]);

  // useFrame(() => {
  //   if (transformController) {
  //     if (!s.mouse) {
  //       s.mouse = { x: mouse.x, y: mouse.y };
  //     } else {
  //       const { x, y, z } = rigidDiningSetRef.current?.translation() || {
  //         x: 0,
  //         y: 0,
  //         z: 0,
  //       };

  //       rigidDiningSetRef.current?.setTranslation({
  //         x: x + (mouse.x - s.mouse.x) * 10,
  //         y: y + (mouse.y - s.mouse.y) * 10,
  //         z: z + ,
  //       });
  //     }
  //   }
  // });

  // useEffect(() => {
  //   const handleMouseUp = () => {
  //     setDragging(false);
  //   };
  //   window.addEventListener("pointerup", handleMouseUp);

  //   return () => {
  //     window.removeEventListener("pointerup", handleMouseUp);
  //   };
  // }, []);

  // useFrame(() => {
  //   if (transformController) {
  //     rigidDiningSetRef.current?.setTranslation({
  //       x: props.position.x,
  //       y: props.position.y,
  //       z: props.position.z,
  //     });
  //     console.log(rigidDiningSetRef.current);
  //   }
  // });

  return (
    <>
      {/* <RigidBody
        ref={rigidDiningSetRef}
        colliders={false}
        restitution={0}
        friction={0.1}
        type={transformController ? "fixed" : "fixed"}
        onCollisionEnter={(e) => {
          if (e.other.colliderObject.name === "floor") {
            if (e.other.colliderObject.position.y > -0.1) {
              setIntersection(true);
            } else {
              setIntersection(false);
            }
          } else {
            setIntersection(true);
          }
        }}
        onCollisionExit={() => {
          setIntersection(false);
        }}
        position={[0, 5, 0]}
      >
        <CuboidCollider
          args={[1, 1, 1]}
          position={[0, 2, 0]}
          collisionGroups={interactionGroups(1, [0, 1])}
        /> */}
        <group
          {...props}
          dispose={null}
          onClick={() => {
            setTransformController(true);
          }}
          onPointerMissed={() => {
            // e.type === "click" && toggleActive(false);
            sceneActions.removeActiveObject();
            console.log(sceneStateStore);

            setTransformController(false);
          }}
          onDoubleClick={(e) => {
            e.stopPropagation();

            sceneActions.setActiveObject(props.objectId);
            // console.log(e.object.instance.current.material.name)
            sceneActions.setActiveMaterial(
              e.object.instance.current.material.name
            );

            setTransformController(false);
            // toggleActive(true);
          }}
          position={[props.position.x, props.position.y, props.position.z]}
          rotation={[props.rotation.x, props.rotation.y, props.rotation.z]}
          scale={[props.scale.x, props.scale.y, props.scale.z]}
          ref={objectRef}
        >
          <instances.Body
            color={colliderColor ? "red" : props.nodes.Body1__0}
            ref={bodyRef}
            onClick={(e) => console.log(e)}
          />
          <instances.BodyPolyurethane
            color={colliderColor ? "red" : props.nodes.Polyurethane}
          />
          <instances.BodyDMahoganyGlossy
            color={colliderColor ? "red" : props.nodes["3D_Mahogany_-_Glossy"]}
          />
          <instances.BodyMirror
            color={colliderColor ? "red" : props.nodes.Mirror}
          />
          <instances.BodyGlassMediumColor
            color={colliderColor ? "red" : props.nodes["Glass_-_Medium_Color"]}
          />
          <instances.BodyDMahoganyGlossy1
            color={colliderColor ? "red" : props.nodes["3D_Mahogany_-_Glossy"]}
          />
          <instances.Body1
            color={colliderColor ? "red" : props.nodes.Body1__0}
          />
          <instances.BodyPolyurethane1
            color={colliderColor ? "red" : props.nodes.Polyurethane}
          />
          <instances.Body2
            color={colliderColor ? "red" : props.nodes.Body1__0}
          />
          <instances.BodyPolyurethane2
            color={colliderColor ? "red" : props.nodes.Polyurethane}
          />
          <instances.Body3
            color={colliderColor ? "red" : props.nodes.Body1__0}
          />
          <instances.BodyPolyurethane3
            color={colliderColor ? "red" : props.nodes.Polyurethane}
          />
          <instances.Body4
            color={colliderColor ? "red" : props.nodes.Body1__0}
          />
          <instances.BodyPolyurethane4
            color={colliderColor ? "red" : props.nodes.Polyurethane}
          />
          <instances.BodyOpaque
            color={colliderColor ? "red" : props.nodes.Opaque152170175}
          />
          <instances.BodyOpaque1
            color={colliderColor ? "red" : props.nodes.Opaque152170175}
          />
          <instances.BodyOpaque2
            color={colliderColor ? "red" : props.nodes.Opaque152170175}
          />
          <instances.BodyOpaque3
            color={colliderColor ? "red" : props.nodes.Opaque152170175}
          />
          <instances.BodyOpaque4
            color={colliderColor ? "red" : props.nodes.Opaque152170175}
          />
          <instances.BodyGlassLightColor
            color={colliderColor ? "red" : props.nodes["Glass_-_Light_Color"]}
          />
          <instances.BodyGlassLightColor1
            color={colliderColor ? "red" : props.nodes["Glass_-_Light_Color"]}
          />
          <instances.BodyGlassLightColor2
            color={colliderColor ? "red" : props.nodes["Glass_-_Light_Color"]}
          />
          <instances.BodyGlassLightColor3
            color={colliderColor ? "red" : props.nodes["Glass_-_Light_Color"]}
          />
          <instances.BodyGlassLightColor4
            color={colliderColor ? "red" : props.nodes["Glass_-_Light_Color"]}
          />
        </group>
      {transformController && (
        <ObjectTransformControls
          id={props.objectId}
          object={objectRef.current}
        />
      )}
    </>
  );
}

// useGLTF.preload("/dining_set-transformed.glb");
