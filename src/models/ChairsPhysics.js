/* eslint-disable react/no-unknown-property */
/* eslint-disable react/no-children-prop */
/* eslint-disable react/prop-types */
/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
Command: npx gltfjsx@6.1.3 chairs.glb --instanceall
*/

import { Merged, useGLTF } from "@react-three/drei";
import { CuboidCollider, RigidBody } from "@react-three/rapier";
import React, {
  createContext,
  useContext,
  useLayoutEffect,
  useMemo,
  useRef,
  useState
} from "react";
import * as THREE from "three";
import { subscribe } from "valtio";
import ObjectTransformControls from "../components/ObjectTransformControls";
import { sceneActions, sceneStateStore } from "../store/sceneData";

const context = createContext();

// eslint-disable-next-line no-unused-vars
const remapMaterialUVs = (
  material,
  remapUVs,
  // eslint-disable-next-line no-unused-vars
  { uvAttributePrefix, uvAttributeOffset } = {}
) => {
  const _uvAttributePrefix = uvAttributePrefix || "texcoord_";
  const _uvAttributeOffset = 2; 

  material.customProgramCacheKey = () => Math.random();
  // eslint-disable-next-line no-unused-vars
  material.onBeforeCompile = (shader, context) => {
    const resolveIncludes = (shader) => {
      // NOTE Straight from three/WebGLProgram.js
      const includePattern = /^[ \t]*#include +<([\w\d./]+)>/gm;

      return shader.replace(includePattern, (match, include) => {
        const string = THREE.ShaderChunk[include];

        if (!string) {
          return;
        }

        return resolveIncludes(string);
      });
    };

    let maxTexCoordIndex = 0;
    const texCoordSwaps = [];

    Object.entries(remapUVs).forEach(([textureType, uvMap]) => {
      if (!uvMap.startsWith(_uvAttributePrefix)) {
        console.warn("Invalid UVMap name", uvMap);

        return;
      }

      const texCoordIndex = parseFloat(
        uvMap.split(new RegExp(`${_uvAttributePrefix}\\D*`, "gi")).join("")
      );

      maxTexCoordIndex = Math.max(texCoordIndex, maxTexCoordIndex);
      texCoordSwaps[textureType] = texCoordIndex;
    });

    if (maxTexCoordIndex - 1 <= 0) {
      return;
    }

    shader.vertexShader = shader.vertexShader
      .replace(
        `#include <uv2_pars_vertex>`,
        `
      ${Array(maxTexCoordIndex - 1)
        .fill(0)
        .map(
          (_, index) => `
        attribute vec2 ${_uvAttributePrefix}${index + _uvAttributeOffset};
        varying vec2 vTexCoord${index + _uvAttributeOffset};
      `
        )
        .join("\n")}

      #include <uv2_pars_vertex>
    `
      )
      .replace(
        `#include <uv2_vertex>`,
        `
      ${Array(maxTexCoordIndex - 1)
        .fill(0)
        .map(
          (_, index) => `
        vTexCoord${index + _uvAttributeOffset} = ( vec3( ${_uvAttributePrefix}${
            index + _uvAttributeOffset
          }, 1 ) ).xy;
      `
        )
        .join("\n")}

      #include <uv2_vertex>
    `
      );

    shader.fragmentShader = shader.fragmentShader.replace(
      `#include <uv2_pars_fragment>`,
      `
      ${Array(maxTexCoordIndex - 1)
        .fill(0)
        .map(
          (_, index) => `
        varying vec2 vTexCoord${index + _uvAttributeOffset};
      `
        )
        .join("\n")}

      #include <uv2_pars_fragment>
    `
    );

    shader.vertexShader = resolveIncludes(shader.vertexShader);
    shader.fragmentShader = resolveIncludes(shader.fragmentShader);

    Object.entries(texCoordSwaps).forEach(([textureType, texCoordIndex]) => {
      shader.fragmentShader = shader.fragmentShader
        .replaceAll(
          `texture2D( ${textureType}, vUv )`,
          `texture2D( ${textureType}, vTexCoord${texCoordIndex} )`
        )
        .replaceAll(
          `texture2D( ${textureType}, vUv2 )`,
          `texture2D( ${textureType}, vTexCoord${texCoordIndex} )`
        );
    });
  };
};

export function ChairsInstances({ children, ...props }) {
  const { nodes } = useGLTF("/chairs-transformed.glb");
  const instances = useMemo(
    () => ({
      Body: nodes.Body49__0,
      BodyPolyurethane: nodes.Body50_Polyurethane_0,
    }),
    [nodes]
  );
  return (
    <Merged meshes={instances} {...props}>
      {(instances) => (
        <context.Provider value={instances} children={children} />
      )}
    </Merged>
  );
}

export function Chairs(props) {
  const instances = useContext(context);

  const objectRef = useRef();

  const [transformController, setTransformController] = useState(false);

  const bodyPolyurethaneRef = useRef();

  useLayoutEffect(() => {
    subscribe(
      sceneStateStore,
      () => {
        if (sceneStateStore.current.texture === "rattan") {
          remapMaterialUVs(
            bodyPolyurethaneRef.current.instance.current.material,
            {
              map: "texcoord_2", //texcoord_2
            }
          );
          bodyPolyurethaneRef.current.instance.current.material.needsUpdate = true;
        } else if (sceneStateStore.current.texture === "default") {
          remapMaterialUVs(
            bodyPolyurethaneRef.current.instance.current.material,
            {
              map: "texcoord_1",
            }
          );
          bodyPolyurethaneRef.current.instance.current.material.needsUpdate = true;
        }
      },
      []
    );
  }, []);

  const rigidChairsRef = useRef();

  /** Set sensor interaction for colliding meshes */
  const [intersecting, setIntersection] = useState(false);

  // useFrame(() => {
  //   if (transformController) {
  //     // const { x, y, z } = rigidChairsRef.current?.translation() || {
  //     //   x: 0,
  //     //   y: 0,
  //     //   z: 0,
  //     // };

  //     rigidChairsRef.current?.setTranslation({
  //       x: props.position.x,
  //       y: props.position.y,
  //       z: props.position.z,
  //     });

  //     // rigidChairsRef.current?.setTranslation({
  //     //   x: props.position.x,
  //     //   y: props.position.y,
  //     //   z: props.position.z,
  //     // });
  //   }
  // });

  // useEffect(() => {
  //   if (transformController) {
  //     if (props.position.x) {
  //       console.log("changing x");
  //       // rigidChairsRef.current.applyImpulse({ x: 1, y: 0, z: 0 });
  //     }
  //     // rigidChairsRef.current?.setTranslation({
  //     //   x: props.position.x,
  //     //   y: props.position.y,
  //     //   z: props.position.z,
  //     // });
  //   }
  // }, [transformController]);

  return (
    <>
      <RigidBody
        ref={rigidChairsRef}
        colliders={false}
        position={[
          props.position.x,
          props.position.y,
          props.position.z,
        ]}
        type={transformController ? "dynamic" : "fixed"}
        onCollisionEnter={(e) => {
          if (e.other.colliderObject.name === "floor") {
            if (e.other.colliderObject.position.y > -0.1) {
              console.log("more than -0.1");
              setIntersection(true);
            } else {
              console.log("less than -0.1");
              setIntersection(false);
            }
          } else {
            setIntersection(true);
          }
          console.log("colliding")
        }}
        onCollisionExit={() => {
          setIntersection(false);
        }}
      >
        <CuboidCollider args={[7.5, 2.6, 7.5]} position={[0, 2.6, 0]} />
        <group
          {...props}
          dispose={null}
          onClick={() => {
            setTransformController(true);
          }}
          onPointerMissed={() => {
            // e.type === "click" && toggleActive(false);
            sceneActions.removeActiveObject();
            // console.log(sceneStateStore);

            setTransformController(false);
          }}
          onDoubleClick={(e) => {
            e.stopPropagation();

            sceneActions.setActiveObject(props.objectId);
            // console.log(e.object.instance.current.material.name)
            sceneActions.setActiveMaterial(
              e.object.instance.current.material.name
            );

            setTransformController(false);
            // toggleActive(true);
          }}
          position={[0, 0, 0]}
          rotation={[0, 0, 0]}
          scale={[4, 4, 4]}
          // position={[props.position.x, props.position.y, props.position.z]}
          // rotation={[props.rotation.x, props.rotation.y, props.rotation.z]}
          // scale={[props.scale.x, props.scale.y, props.scale.z]}
          ref={objectRef}
        >
          <instances.Body color={intersecting ? "red" : "white"} />
          <instances.BodyPolyurethane
            color={intersecting ? "red" : "white"}
            ref={bodyPolyurethaneRef}
            onClick={(e) => {
              console.log(e);
            }}
          />
        </group>
      </RigidBody>
      {transformController && (
        <ObjectTransformControls
          id={props.objectId}
          object={objectRef.current}
        />
      )}
    </>
  );
}

// useGLTF.preload("/chairs-transformed.glb");
